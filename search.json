[
  {
    "objectID": "starting_points.html",
    "href": "starting_points.html",
    "title": "Graphing around with Solr",
    "section": "",
    "text": "The null query selects all nodes as indicated by the red outlines of the nodes."
  },
  {
    "objectID": "starting_points.html#nodes-with-outgoing-edges.",
    "href": "starting_points.html#nodes-with-outgoing-edges.",
    "title": "Graphing around with Solr",
    "section": "Nodes with outgoing edges.",
    "text": "Nodes with outgoing edges.\nThis is the set of documents that contain nested documents.\nQuery says, use the !parent query parser to find the set of documents that have a _nest_path_ value and return the parents of those documents.\n\n\nShow the code\nex1 = '''\nsearch(reltest,\n    q=\"{!parent \n        which='*:* -_nest_path_:*'\n       }(+_nest_path_:*)\",\n    fl=\"*\",\n    rows=100\n)\n'''\nprint(ex1)\nres = solr.sendExpr(ex1)\nsolr.render(example_graph.docs, res)\n\n\n\nsearch(reltest,\n    q=\"{!parent \n        which='*:* -_nest_path_:*'\n       }(+_nest_path_:*)\",\n    fl=\"*\",\n    rows=100\n)"
  },
  {
    "objectID": "starting_points.html#nodes-with-no-outgoing-edges.",
    "href": "starting_points.html#nodes-with-no-outgoing-edges.",
    "title": "Graphing around with Solr",
    "section": "Nodes with no outgoing edges.",
    "text": "Nodes with no outgoing edges.\nThis is the set of documents with no nested documents\n\n\nShow the code\nex1 = '''\nsearch(reltest,\n    q=\"-_nest_path_:* AND !(\n        {!parent \n            which='*:* AND -_nest_path_:*'\n        }+_nest_path_:*)\",\n    rows=100\n)\n'''\nprint(ex1)\nres = solr.sendExpr(ex1)\nsolr.render(example_graph.docs, res)\n\n\n\nsearch(reltest,\n    q=\"-_nest_path_:* AND !(\n        {!parent \n            which='*:* AND -_nest_path_:*'\n        }+_nest_path_:*)\",\n    rows=100\n)"
  },
  {
    "objectID": "starting_points.html#nodes-with-an-incoming-edge",
    "href": "starting_points.html#nodes-with-an-incoming-edge",
    "title": "Graphing around with Solr",
    "section": "Nodes with an incoming edge",
    "text": "Nodes with an incoming edge\nThat is, nodes that are the target of any edge.\nThis approach uses an inner join from the edge target in child documents to the target node.\nNote that the returned records are a composite of the nested child and its parent\n\n\nShow the code\n_left = '''    search(reltest,\n        q=\"_nest_path_:*\",\n        fl=\"target_s,p:relation_type_s,s:_nest_parent_\",\n        rows=1000,\n        sort=\"target_s asc\"\n    )'''\n_right = '''    search(reltest,\n        q=\"-_nest_path_:*\",\n        fl=\"id,*\",\n        rows=1000,\n        sort=\"id asc\"\n    )'''\n\nexpr = f'''\ninnerJoin(\n    {_left},\n    {_right},\n    on=\"target_s=id\"\n)\n'''\nprint(expr)\nres = solr.sendExpr(expr)\nsolr.render(example_graph.docs, res)\n\n\n\ninnerJoin(\n        search(reltest,\n        q=\"_nest_path_:*\",\n        fl=\"target_s,p:relation_type_s,s:_nest_parent_\",\n        rows=1000,\n        sort=\"target_s asc\"\n    ),\n        search(reltest,\n        q=\"-_nest_path_:*\",\n        fl=\"id,*\",\n        rows=1000,\n        sort=\"id asc\"\n    ),\n    on=\"target_s=id\"\n)"
  },
  {
    "objectID": "starting_points.html#nodes-with-no-incoming-edges",
    "href": "starting_points.html#nodes-with-no-incoming-edges",
    "title": "Graphing around with Solr",
    "section": "Nodes with no incoming edges",
    "text": "Nodes with no incoming edges\nThis is a bit complicated because we only know about the outgoing edges. The approach taken here is to find all the documents that are not nested (i.e. not the edges nested documents) and subtract from that set the documents that are the target of an edge using the Solr complement stream decorator.\n\n\nShow the code\n# A is all non-nested documents\nA = '''    search(reltest,\n        q=\"-_nest_path_:*\",\n        fl=\"id,*\",\n        rows=1000,\n        sort=\"id asc\"\n    )'''\n# B is all documents that are the target of a relation\nB = '''fetch(reltest, \n        search(reltest,\n            q=_nest_parent_:*,\n            fl=\"target_s\",\n            sort=\"target_s asc\",\n            rows=1000\n        ),\n        fl=\"id,target_s\",\n        on=\"target_s=id\"\n    )'''\n\n# This doesn't work. I guess the tuples need to be of the same kind of document, not just matching the \"on\" keys?\nC = '''\nsearch(reltest,\n    q=\"_nest_parent_:*\",\n    fl=\"id,target_s\",\n    sort=\"target_s asc\",\n    rows=1000\n)'''\n\n# complement A, B is the list of documents in A that are not in B, or A-B.\nexpr = f'''complement(\n    {A},\n    {B},\n    on=\"id=target_s\"\n)'''\n\nprint(expr)\nres = solr.sendExpr(expr)\nsolr.render(example_graph.docs, res)\n\n\ncomplement(\n        search(reltest,\n        q=\"-_nest_path_:*\",\n        fl=\"id,*\",\n        rows=1000,\n        sort=\"id asc\"\n    ),\n    fetch(reltest, \n        search(reltest,\n            q=_nest_parent_:*,\n            fl=\"target_s\",\n            sort=\"target_s asc\",\n            rows=1000\n        ),\n        fl=\"id,target_s\",\n        on=\"target_s=id\"\n    ),\n    on=\"id=target_s\"\n)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Graphing around with Solr",
    "section": "",
    "text": "Solr graph operations basically involve a breadth-first scan across documents connected by some property from a starting set of documents and optionally applying filters during the traversal or on the resulting set of documents.\nThe following solr document structure is used for these examples. Two nodes are described, a and aa. The node aa contains a single edge of type subsample-of with a target node of a:\n[\n    {\n        \"id\":\"a\",\n        \"name_t\":\"parent a\",\n        \"is_s\":\"sample\",\n        \"_root_\":\"a\",\n    },\n    {\n        \"id\":\"aa\",\n        \"name_t\":\"sub aa\",\n        \"is_s\":\"sample\",\n        \"_root_\":\"aa\",\n        \"edges\":[\n            {\n                \"id\":\"111\",\n                \"relation_type_s\":\"subsample-of\",\n                \"target_s\":\"a\",\n                \"_root_\":\"aa\",\n                \"_nest_parent_\":\"aa\",\n                \"_nest_path_\":\"/related#0\"\n            }\n        ]\n    }\n]\n\n\n\n\n\n\n\nNote\n\n\n\nThe fields _root_, _nest_parent_, and _nest_path_ are computed by Solr, and should not be included in the documents when indexing.\n\nEach document structure has two parts - the main document and a optional list of nested child documents that capture relationships with other documents. In this pattern, the outer document is a node of the property graph, and the child edges documents are the edges. Both nodes and edges may have many properties. Solr will index each of these as individually addressable documents and the index will have columns matching the union of columns used in the node documents and in the edge documents. The above example might appear in the index like (excluding the Solr calculated fields):\n\n\n\nid\nname_t\nis_s\nrelation_type_s\ntarget_s\n\n\n\n\na\nparent a\nsample\n\n\n\n\naa\nsub aa\nsample\n\n\n\n\n111\n\n\nsubsample-of\na\n\n\n\nThe resulting solr index has documents a, aa and 111 in the index with their respective properties. Note that Solr also includes additional properties that record the nested structure. In particular, the properties _nest_parent_, _nest_path_, and _root_ (the latter defaulting to not being presentable in results).\nThe following graph is used in the examples of different operations.\n\n\nShow the code\nimport example_graph\nimport graphutzing\ngraphutzing.generateViz(example_graph.docs)\n\n\n\n\n\nIn the example graph, relations are uni-directional asserting a statement such as “ab is a subsample-of a” and “aaba is an analysis-of aab”, and so forth. The different shapes represent different types of entities as indicated by the is_s property.\nThe complete list of documents in example_graph is shown in Table 1:\n\n\nShow the code\nimport IPython.display\nimport tabulate\nsolr = graphutzing.SolrConnection()\nres = solr.query(data={\"q\":\"*:*\", \"rows\":100, \"sort\":\"is_s DESC, id ASC\",})\nheader = [\"id\",\"name_t\",\"is_s\",\"relation_type_s\",\"target_s\",\"`_nest_parent_`\"]\nrows = []\nfor doc in res.get(\"response\",{}).get(\"docs\",[]):\n    row = [doc.get(\"id\",\"\"),doc.get(\"name_t\",\"\"),doc.get(\"is_s\",\"\"),doc.get(\"relation_type_s\",\"\"),doc.get(\"target_s\",\"\"), doc.get(\"_nest_parent_\",\"\")]\n    rows.append(row)\nIPython.display.Markdown(tabulate.tabulate(\n    rows,\n    headers=header,\n    tablefmt=\"pipe\",\n    colalign=(\"right\",)\n))\n\n\n\n\nTable 1: List of records indexed in example_graph.\n\n\n\n\n\n\n\n\n\n\nid\nname_t\nis_s\nrelation_type_s\ntarget_s\n_nest_parent_\n\n\n\n\na\nparent a\nsample\n\n\n\n\n\naa\nsub aa\nsample\n\n\n\n\n\naa2\nsub aa2\nsample\n\n\n\n\n\naab\nsub aab\nsample\n\n\n\n\n\nab\nsub ab\nsample\n\n\n\n\n\nb\nparent b\nsample\n\n\n\n\n\nba\nsub ba\nsample\n\n\n\n\n\nbb\nsub bb\nsample\n\n\n\n\n\nc\nindependent c\nsample\n\n\n\n\n\nccc\npublication\npublication\n\n\n\n\n\nddd\npublication\npublication\n\n\n\n\n\naaa\nanalysis aaa\nanalysis\n\n\n\n\n\naaba\nsub aaba\nanalysis\n\n\n\n\n\nbaa\nanalysis baa\nanalysis\n\n\n\n\n\n111\n\n\nsubsample-of\na\naa\n\n\n1111\n\n\nsubsample-of\naa\naa2\n\n\n112\n\n\nsubsample-of\na\nab\n\n\n113\n\n\nanalysis-of\naa\naaa\n\n\n114\n\n\nsubsample-of\nb\nba\n\n\n114\n\n\nanalysis-of\naa2\naaa\n\n\n115\n\n\nanalysis-of\nba\nbaa\n\n\n1151\n\n\nanalysis-of\naab\naaba\n\n\n120\n\n\nsubsample-of\nab\naab\n\n\n121\n\n\nsubsample-of\nb\nbb\n\n\nccc1\n\n\nreferences\naaa\nccc\n\n\nccc2\n\n\nreferences\nbaa\nccc\n\n\nddd1\n\n\nreferences\nccc\nddd\n\n\nddd2\n\n\nreferences\naaba\nddd"
  },
  {
    "objectID": "graph_traversal01.html",
    "href": "graph_traversal01.html",
    "title": "Graphing around with Solr",
    "section": "",
    "text": "In the graph model used here the arrows are pointing from the descendant to the ancestor. It is done this way for practical purposes - it is easier to add edges to a derived record than to update an origin record each time a derivative is made. Hence, a subsample-of relation here indicates that the record containing the relation is a subsample of the target of that relation, and the origin is an ancestor of the record. This basic pattern is shown in Figure 1.\n\n\n\n\n\n\n   \n\nnode1\n\n Decendant A derived record   \n\nnode2\n\n Ancestor Intermediate record   \n\nnode1->node2\n\n  subsample-of   \n\nnode3\n\n Ancestor2 The source record   \n\nnode2->node3\n\n  subsample-of  \n\n\nFigure 1: Ancestor2 is the original source record, Ancestor is a sample-of Ancestor2, and Descendant is a sample-of Ancestor.\n\n\n\n\nExpressed as JSON records:\n[\n    {\n        \"id\":\"Ancestor2\",\n        \"name_t\":\"The source record\",\n        \"_root_\":\"Ancestor\"\n    },\n    {\n        \"id\":\"Ancestor\",\n        \"name_t\":\"A derived record\",\n        \"_root_\":\"Ancestor\",\n        \"edges\":[\n            {\n                \"id\":\"relation_01\",\n                \"relation_type_s\":\"subsample-of\",\n                \"target_s\":\"Ancestor2\",\n                \"_nest_parent_\":\"Ancestor\",\n                \"_root_\":\"Ancestor\",\n                \"_nest_path_\":\"/edges#0\"\n            }\n        ]\n    },\n    {\n        \"id\":\"Descendant\",\n        \"name_t\":\"Another derived record\",\n        \"_root_\":\"Descendant\",\n        \"edges\":[\n            {\n                \"id\":\"relation_02\",\n                \"relation_type_s\":\"subsample-of\",\n                \"target_s\":\"Ancestor\",\n                \"_nest_parent_\":\"Descendant\",\n                \"_root_\":\"Descendant\",\n                \"_nest_path_\":\"/edges#0\"\n            }\n        ]\n    }\n]\n\n\n\n\n\n\n\nNote\n\n\n\nThe fields _root_, _nest_parent_, and _nest_path_ are computed by Solr, and should not be included in the documents when indexing. They are included here to indicate the values set by Solr.\n\nThe basic form of a solr query for this operation is a graph expression traversing from a descendant record to targets of the relations.\nThe graph query:\n{!graph from=FROM_FIELD to=TO_FIELD}ROOT_DOCUMENTS\nroughly corresponds to the pseudo code:\nstart_docs = ROOT_DOCUMENTS\nwhile start_docs is not empty:\n    for each document in start_docs:\n        for each value of TO_FIELD:\n            set start_docs to documents with FROM_FIELD matching value\nWhere:\n\nFROM_FIELD\n\nName of the field examined for incoming edges.\n\nTO_FIELD\n\nName of the field listing outgoing edges.\n\nROOT_DOCUMENTS\n\nThe list of documents providing starting points for graph traversal.\n\n\nIn the two node example above, FROM_FIELD corresponds to the parent of the related edge documents and TO_FIELD corresponds with the target_s value of the edge document.\nSince relations are held in the nested documents, it is necessary to seed the starting points of the graph traversal with the nested child relation documents, however we are typically quarying on properties of the parent of the nested child. Hence the root nodes for starting the traversal are found by selecting the child documents of parent documents that match some filter. This is done using the Solr !child query parser:\n{!child of=PARENT_MASK}SOME_PARENTS\nwhere:\n\nSOME_PARENTS\n\nQuery returing some parent documents, e.g. *:* or id:Descendant.\n\nPARENT_MASK\n\nFilter applied to SOME_PARENTS. This will typically match all parent documents, e.g. *:* -_nest_path_:* (all documents in SOME_PARENTS that don’t have a _nest_path_ field).\n\n\nCombining the !graph and !child query parsers provides a pattern facilitating traversal across ancestor documents. For example:\n{!graph \n    from=_nest_parent_ \n    to=target_s\n}(  \n    {!child\n        of=\"*:* -_nest_path_:*\"\n    }id:Descendant\n)\nSays given the child document of the document with id of “Descendant”, get documents with _nest_parent_ matching the value of _target_s. At this point, we have all the related nested documents that point to ancestors of “Descendant”, which in this case is simply the single document with identifier “relation_01”.\nNote that the ancestors are actually the documents that are referenced from the value of the target_s field. There are a couple options to retrieve those documents. One is the !join query parser:\n{!join\n    from=target_s\n    to=id\n}(\n    {!graph \n        from=_nest_parent_ \n        to=target_s\n    }(  \n        {!child\n            of=\"*:* -_nest_path_:*\"\n        }id:Descendant\n    )\n)\nAn alternative, when using streaming expressesions is to use the fetch stream decorator:\nfetch(COLLECTION,\n    search(COLLECTION,\n        q=\"{!graph \n                from=_nest_parent_ \n                to=target_s\n            }(  \n            {!child\n                of='*:* -_nest_path_:*'\n            }id:Descendant\n        )\",\n    ),\n    fl=\"id, name_t\",\n    on=\"target_s=id\"\n)\n\n\nThe two ancestor approaches are illustrated here using the example_graph.\nIn both cases, we are looking for all records that are the ancestors of the node id:ddd. This could easily be expanded to include many starting root nodes by adjusting the initial filter query to match multiple nodes..\nThe first uses the !join query expression. See Figure 2.\n\n\nShow the code\nimport example_graph\nimport graphutzing\n\nsolr = graphutzing.SolrConnection()\n\nex0 = '''search(reltest,\n    q=\"{!join \n            from=target_s \n            to=id\n        }{!graph \n            from=_nest_parent_ \n            to=target_s\n        }({!child \n            of='*:* -_nest_path_:*'\n        }id:ddd)\",\n    fl=\"*\",\n    rows=100\n)'''\nprint(ex0)\nres = solr.sendExpr(ex0)\nsolr.render(example_graph.docs, res)\n\n\nsearch(reltest,\n    q=\"{!join \n            from=target_s \n            to=id\n        }{!graph \n            from=_nest_parent_ \n            to=target_s\n        }({!child \n            of='*:* -_nest_path_:*'\n        }id:ddd)\",\n    fl=\"*\",\n    rows=100\n)\n\n\n\n\n\nFigure 2: A line plot on a polar axis\n\n\n\n\nThe second uses the fetch stream decorator, see Figure 3:\n\n\nShow the code\nex1 = '''search(reltest,\n        q=\"{!graph \n            to=target_s \n            from=_nest_parent_\n        }({!child \n            of='*:* -_nest_path_:*'\n        }id:ddd)\",\n        fl=\"*\",\n        rows=100\n    )'''\nex2 = f'''\nfetch(reltest,\n    {ex1},\n    fl=\"id,name_t\",\n    on=\"target_s=id\"\n)'''\nprint(ex2)\nres = solr.sendExpr(ex2)\nsolr.render(example_graph.docs, res)\n\n\n\nfetch(reltest,\n    search(reltest,\n        q=\"{!graph \n            to=target_s \n            from=_nest_parent_\n        }({!child \n            of='*:* -_nest_path_:*'\n        }id:ddd)\",\n        fl=\"*\",\n        rows=100\n    ),\n    fl=\"id,name_t\",\n    on=\"target_s=id\"\n)\n\n\n\n\n\nFigure 3: A line plot on a polar axis\n\n\n\n\n\n\n\nThis pattern can be used to find ancestors that match a filter.\nIn this case, documents that are the ancestor of ccc are found by an ancestor graph traversal, then only the documents from that set that are samples (is_s:sample) are returned.\n\n\nShow the code\nex1 = '''    search(reltest, \n            q=\"{!graph \n                to=target_s \n                from=_nest_parent_\n            }(_nest_parent_:ccc)\",\n            fl=\"*,target_s,_nest_parent_,[child]\",\n            rows=100\n        )'''\n# Using the fetch operation to retrieve fields from documents found in the graph walk\nex2 = f'''fetch(reltest,\n    {ex1},\n        fl=\"id,name_t,is_s,[child]\",\n        on=\"target_s=id\"\n    )'''\nex3 = f'''\nhaving(\n    {ex2}, \n    eq(is_s,\"sample\")\n)'''\nprint(ex3)\nres = solr.sendExpr(ex3)\nsolr.render(example_graph.docs, res)\n\n\n\nhaving(\n    fetch(reltest,\n        search(reltest, \n            q=\"{!graph \n                to=target_s \n                from=_nest_parent_\n            }(_nest_parent_:ccc)\",\n            fl=\"*,target_s,_nest_parent_,[child]\",\n            rows=100\n        ),\n        fl=\"id,name_t,is_s,[child]\",\n        on=\"target_s=id\"\n    ), \n    eq(is_s,\"sample\")\n)"
  },
  {
    "objectID": "graph_traversal01.html#descendants",
    "href": "graph_traversal01.html#descendants",
    "title": "Graphing around with Solr",
    "section": "Descendants",
    "text": "Descendants\nFinding Descendants is similar to finding ancestors, except we are walking the graph in the opposite direction, so the to and from properties of the !graph expression are reversed. Since the Descendants contain the nested relations, retrieving the parent document is a bit simpler since it is just the documents with id matching _nest_parent_.\n\nDescendants of a node\nIn this example derivatives (i.e. Descendants) of id:b are found.\n\n\nShow the code\nex1 = '''    search(\n        reltest,\n        q=\"{!graph \n            to=_nest_parent_ \n            from=target_s\n        }target_s:b\",\n        fl=\"*\",\n        rows=100\n    )'''\nex2 = f'''fetch(\n    reltest,\n    {ex1},\n    fl=\"id,name_t,[child]\",\n    on=\"_nest_parent_=id\"\n)\n'''\nprint(ex2)\nres = solr.sendExpr(ex2)\nsolr.render(example_graph.docs, res)\n\n\nfetch(\n    reltest,\n        search(\n        reltest,\n        q=\"{!graph \n            to=_nest_parent_ \n            from=target_s\n        }target_s:b\",\n        fl=\"*\",\n        rows=100\n    ),\n    fl=\"id,name_t,[child]\",\n    on=\"_nest_parent_=id\"\n)\n\n\n\n\n\n\nAlternatively, we can use the !parent query parser to similar effect:\n\n\nShow the code\nex1 = '''search(reltest,\n    q=\"{!parent which='*:* -_nest_path_:*'}({!graph \n        to=_nest_parent_ \n        from=target_s\n    }target_s:b)\",\n    fl=\"*\",\n    rows=100\n)'''\nprint(ex1)\nres = solr.sendExpr(ex1)\nsolr.render(example_graph.docs, res)\n\n\nsearch(reltest,\n    q=\"{!parent which='*:* -_nest_path_:*'}({!graph \n        to=_nest_parent_ \n        from=target_s\n    }target_s:b)\",\n    fl=\"*\",\n    rows=100\n)\n\n\n\n\n\n\n\nDescendants matching a particular type\nIn this case we are looking for analyses that were performed on material derived from sample a.\nWe follow the Descendants graph, but limit the traversal to only include sample-of or analysis-of relations to limit the reduce the scope of traversal. This exclusion is optional, but included here to illustrate the effect of the traversal_filter option. The resulting set of nodes includes samples and analyses. The analysis nodes are selected from that set using the having clause.\n\n\nShow the code\n# Start with a as the target of a relation\nq1 = 'target_s:a'\n# Traverse the graph starting from q1, limit relations being followed to sample-of and analysis-of\nq2 = '{!graph to=_nest_parent_ from=target_s traversal_filter=\"relation_type_s:[subsample-of OR analysis-of]\"}'\nex1 = '''search(\n            reltest,\n            q=\"{!graph \n                to=_nest_parent_ \n                from=target_s \n                traversal_filter='relation_type_s:[subsample-of OR analysis-of]'\n            }target_s:a\",\n            fl=\"*\",\n            rows=100\n        )'''\n# Fetch the records\nex2 = f'''fetch(\n        reltest,\n        {ex1},\n        fl=\"id,name_t,is_s,[child]\",\n        on=\"_nest_parent_=id\"\n    )'''\n# And include only records that are an analysis\nex3 = f'''having(\n    {ex2}, \n    eq(is_s,\"analysis\")\n)'''\nprint(ex3)\nres = solr.sendExpr(ex3)\nsolr.render(example_graph.docs, res)\n\n\nhaving(\n    fetch(\n        reltest,\n        search(\n            reltest,\n            q=\"{!graph \n                to=_nest_parent_ \n                from=target_s \n                traversal_filter='relation_type_s:[subsample-of OR analysis-of]'\n            }target_s:a\",\n            fl=\"*\",\n            rows=100\n        ),\n        fl=\"id,name_t,is_s,[child]\",\n        on=\"_nest_parent_=id\"\n    ), \n    eq(is_s,\"analysis\")\n)"
  },
  {
    "objectID": "graph_traversal01.html#graph-math",
    "href": "graph_traversal01.html#graph-math",
    "title": "Graphing around with Solr",
    "section": "Graph Math",
    "text": "Graph Math\n\nUnion of two graphs\nIn the simplest case, this is following ancestors or descendants from two or more root nodes. In the case where there are two graphs constructed differently and we need the set of all nodes included in both, then we can OR the two queries and if necessary apply a Unique stream decorator.\n\n\nDifference of two graphs\nUse the conjunction stream decorator.\n\n\nNumber of nodes in a graph\nCan be achieved programmatically by counting the nodes or by applying an operation such as rollup using a count(*) metric."
  },
  {
    "objectID": "graph_traversal01.html#other-solr-graph-methods",
    "href": "graph_traversal01.html#other-solr-graph-methods",
    "title": "Graphing around with Solr",
    "section": "Other Solr graph methods",
    "text": "Other Solr graph methods\n\nshortestPath\nThe shortestPath stream source computes the paths between two node, returned as a list of tuples. Each tuple contains the node IDs on a path between the starting nodes.\n\n\nShow the code\nexpr = '''shortestPath(\n    reltest,\n    from=\"ddd\",\n    to=\"a\",\n    edge=\"_nest_parent_=target_s\",\n    maxDepth=50\n)'''\nprint(expr)\nres = solr.sendExpr(expr)\nsolr.render(example_graph.docs, res, show_docs=True, show_graph=False)\n\n\nshortestPath(\n    reltest,\n    from=\"ddd\",\n    to=\"a\",\n    edge=\"_nest_parent_=target_s\",\n    maxDepth=50\n)\n{\n  \"result-set\": {\n    \"docs\": [\n      {\n        \"path\": [\n          \"ddd\",\n          \"ccc\",\n          \"aaa\",\n          \"aa\",\n          \"a\"\n        ]\n      },\n      {\n        \"path\": [\n          \"ddd\",\n          \"aaba\",\n          \"aab\",\n          \"ab\",\n          \"a\"\n        ]\n      },\n      {\n        \"EOF\": true,\n        \"RESPONSE_TIME\": 16\n      }\n    ]\n  }\n}\n\n\n\n\nnodes\nThe nodes stream source does graph traversal, but does not iterate across all nodes of the graph. Instead the operation traverses one level at a time. nodes sources may be nested to reach deeper into a graph.\n\n\nShow the code\nexpr = '''nodes(reltest,\n    nodes(\n        reltest,\n        walk=\"ddd->_nest_parent_\",\n        gather=\"target_s\",\n        scatter=\"branches, leaves\"\n    ),\n    walk=\"node->_nest_parent_\",\n    gather=\"target_s\",\n    scatter=\"branches, leaves\"\n)'''\nprint(expr)\nres = solr.sendExpr(expr)\nsolr.render(example_graph.docs, res, show_docs=True, show_graph=False)\n\n\nnodes(reltest,\n    nodes(\n        reltest,\n        walk=\"ddd->_nest_parent_\",\n        gather=\"target_s\",\n        scatter=\"branches, leaves\"\n    ),\n    walk=\"node->_nest_parent_\",\n    gather=\"target_s\",\n    scatter=\"branches, leaves\"\n)\n{\n  \"result-set\": {\n    \"docs\": [\n      {\n        \"node\": \"ddd\",\n        \"collection\": \"reltest\",\n        \"field\": \"node\",\n        \"level\": 0\n      },\n      {\n        \"node\": \"ccc\",\n        \"collection\": \"reltest\",\n        \"field\": \"target_s\",\n        \"level\": 1\n      },\n      {\n        \"node\": \"aaba\",\n        \"collection\": \"reltest\",\n        \"field\": \"target_s\",\n        \"level\": 1\n      },\n      {\n        \"node\": \"aaa\",\n        \"collection\": \"reltest\",\n        \"field\": \"target_s\",\n        \"level\": 2\n      },\n      {\n        \"node\": \"aab\",\n        \"collection\": \"reltest\",\n        \"field\": \"target_s\",\n        \"level\": 2\n      },\n      {\n        \"node\": \"baa\",\n        \"collection\": \"reltest\",\n        \"field\": \"target_s\",\n        \"level\": 2\n      },\n      {\n        \"EOF\": true,\n        \"RESPONSE_TIME\": 9\n      }\n    ]\n  }\n}"
  }
]